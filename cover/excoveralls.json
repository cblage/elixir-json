{"source_files":[{"name":"lib/json.ex","source":"defmodule JSON do\n  @moduledoc \"\"\"\n  Provides a RFC 7159, ECMA 404, and JSONTestSuite compliant JSON Encoder / Decoder\n  \"\"\"\n\n  require Logger\n\n  alias JSON.Encoder, as: Encoder\n  alias JSON.Decoder, as: Decoder\n\n  @vsn \"1.0.2\"\n\n  @doc \"\"\"\n  Returns a JSON string representation of the Elixir term\n\n  ## Examples\n\n      iex> JSON.encode([result: \"this will be a JSON result\"])\n      {:ok, \"{\\\\\\\"result\\\\\\\":\\\\\\\"this will be a JSON result\\\\\\\"}\"}\n\n  \"\"\"\n  @spec encode(term) :: {atom, bitstring}\n  def encode(term), do: Encoder.encode(term)\n\n  @doc \"\"\"\n  Returns a JSON string representation of the Elixir term, raises errors when something bad happens\n\n  ## Examples\n\n      iex> JSON.encode!([result: \"this will be a JSON result\"])\n      \"{\\\\\\\"result\\\\\\\":\\\\\\\"this will be a JSON result\\\\\\\"}\"\n\n  \"\"\"\n  @spec encode!(term) :: bitstring\n  def encode!(term) do\n    case Encoder.encode(term) do\n      {:ok, value} -> value\n      {:error, error_info} -> raise JSON.Encoder.Error, error_info: error_info\n      _ -> raise JSON.Encoder.Error\n    end\n  end\n\n  @doc \"\"\"\n  Converts a valid JSON string into an Elixir term\n\n  ## Examples\n\n      iex> JSON.decode(\"{\\\\\\\"result\\\\\\\":\\\\\\\"this will be an Elixir result\\\\\\\"}\")\n      {:ok, Enum.into([{\"result\", \"this will be an Elixir result\"}], Map.new)}\n  \"\"\"\n  @spec decode(bitstring) :: {atom, term}\n  @spec decode(charlist) :: {atom, term}\n  def decode(bitstring_or_char_list) do\n    bitstring_or_char_list |>\n      Decoder.decode() |>\n      case  do\n       res = {:ok, _} ->\n         Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring_or_char_list}} was sucesfull: #{inspect res}\")\n         res\n       e = {:error, {:unexpected_token, tok}} ->\n         Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} unexpected token #{tok}\")\n         e\n       e = {:error, :unexpected_end_of_buffer} ->\n         Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} end of buffer\")\n         e\n       e ->\n         Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} an unknown problem occurred #{inspect e}\")\n     end\n  end\n\n  @doc \"\"\"\n  Converts a valid JSON string into an Elixir term, raises errors when something bad happens\n\n  ## Examples\n\n      iex> JSON.decode!(\"{\\\\\\\"result\\\\\\\":\\\\\\\"this will be an Elixir result\\\\\\\"}\")\n      Enum.into([{\"result\", \"this will be an Elixir result\"}], Map.new)\n  \"\"\"\n  @spec decode!(bitstring) :: term\n  @spec decode!(charlist) :: term\n  def decode!(bitstring_or_char_list) do\n    case Decoder.decode(bitstring_or_char_list) do\n      {:ok, value} ->\n        Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} was sucesfull: #{inspect value}\")\n        value\n      {:error, {:unexpected_token, tok}} ->\n        Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} unexpected token #{tok}\")\n        raise JSON.Decoder.UnexpectedTokenError, token: tok\n      {:error, :unexpected_end_of_buffer} ->\n        Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} end of buffer\")\n        raise JSON.Decoder.UnexpectedEndOfBufferError\n      e ->\n        Logger.debug(\"#{__MODULE__}.decode!(#{inspect bitstring_or_char_list}} an unknown problem occurred #{inspect e}\")\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,null,null,null,null,null,null,null,null,null,null,null,1,1,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,76,null,56,56,null,12,12,null,8,8,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,1,1,null,0,0,null,0,0,null,0,null,null,null]},{"name":"lib/json/decoder.ex","source":"defprotocol JSON.Decoder do\n  @moduledoc \"\"\"\n  Defines the protocol required for converting raw JSON into Elixir terms\n  \"\"\"\n\n  @doc \"\"\"\n  Returns an atom and an Elixir term\n  \"\"\"\n  @spec decode(any) :: {atom, term}\n  def decode(bitstring_or_char_list)\nend\n\ndefmodule JSON.Decoder.DefaultImplementations do\n  require Logger\n\n  defimpl JSON.Decoder, for: BitString do\n    @moduledoc \"\"\"\n    JSON Decoder implementation for BitString values\n    \"\"\"\n\n    alias JSON.Parser, as: Parser\n\n    @doc \"\"\"\n    decodes json in BitString format\n\n    ## Examples\n\n        iex> JSON.Decoder.decode \"\"\n        {:error, :unexpected_end_of_buffer}\n\n        iex> JSON.Decoder.decode \"face0ff\"\n        {:error, {:unexpected_token, \"face0ff\"}}\n\n        iex> JSON.Decoder.decode \"-hello\"\n        {:error, {:unexpected_token, \"-hello\"}}\n\n    \"\"\"\n    def decode(bitstring) do\n      Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}) starting...\")\n      bitstring\n      |> String.trim()\n      |> Parser.parse()\n      |> case do\n           {:error, error_info} ->\n              Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}} failed with errror: #{inspect error_info}\")\n              {:error, error_info}\n           {:ok, value, rest} ->\n             Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}) trimming remainder of JSON payload #{inspect rest}...\")\n             case rest |> String.trim() do\n               <<>> ->\n                 Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}) successfully trimmed remainder JSON payload!\")\n                 Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}) returning {:ok. #{inspect value}}\")\n                 {:ok, value}\n               rest ->\n                 Logger.debug(\"#{__MODULE__}.decode(#{inspect bitstring}} failed consume entire buffer: #{rest}\")\n                 {:error, {:unexpected_token, rest}}\n             end\n         end\n    end\n  end\n\n  defimpl JSON.Decoder, for: List do\n    @moduledoc \"\"\"\n    JSON Decoder implementation for Charlist values\n    \"\"\"\n\n    alias JSON.Decoder, as: Decoder\n\n    @doc \"\"\"\n    decodes json in BitString format\n\n    ## Examples\n\n        iex> JSON.Decoder.decode \"\"\n        {:error, :unexpected_end_of_buffer}\n\n        iex> JSON.Decoder.decode \"face0ff\"\n        {:error, {:unexpected_token, \"face0ff\"}}\n\n        iex> JSON.Decoder.decode \"-hello\"\n        {:error, {:unexpected_token, \"-hello\"}}\n\n    \"\"\"\n    def decode(charlist) do\n      charlist |>\n        to_string() |>\n        Decoder.decode() |>\n        case do\n          {:ok, value} -> {:ok, value}\n          {:error, error_info} when is_binary(error_info)  ->\n            Logger.debug(\"#{__MODULE__}.decode(#{inspect charlist}} failed with errror: #{inspect error_info}\")\n            {:error, error_info |> to_charlist()}\n          {:error, {:unexpected_token, bin}} when is_binary(bin)  ->\n            Logger.debug(\"#{__MODULE__}.decode(#{inspect charlist}} failed with errror: #{inspect bin}\")\n            {:error, {:unexpected_token, bin |> to_charlist()}}\n          e = {:error, error_info} ->\n            Logger.debug(\"#{__MODULE__}.decode(#{inspect charlist}} failed with errror: #{inspect e}\")\n            {:error, error_info}\n        end\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,77,null,null,null,77,null,18,null,null,59,59,null,57,57,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,null,35,null,null,0,null,null,6,null,null,4,null,null,null,null,null]},{"name":"lib/json/encoder/default_implementations.ex","source":"defimpl JSON.Encoder, for: Tuple do\n  @doc \"\"\"\n  Encodes an Elixir tuple into a JSON array\n  \"\"\"\n  def encode(term), do: term |> Tuple.to_list() |> JSON.Encoder.Helpers.enum_encode()\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof(_), do: :array\nend\n\ndefimpl JSON.Encoder, for: HashDict do\n  @doc \"\"\"\n  Encodes an Elixir HashDict into a JSON object\n  \"\"\"\n  def encode(dict), do: JSON.Encoder.Helpers.dict_encode(dict)\n\n  @doc \"\"\"\n  Returns :object\n  \"\"\"\n  def typeof(_), do: :object\nend\n\ndefimpl JSON.Encoder, for: List do\n  @doc \"\"\"\n  Encodes an Elixir List into a JSON array\n  \"\"\"\n  def encode([]), do: {:ok, \"[]\"}\n\n  def encode(list) do\n    if Keyword.keyword?(list) do\n      JSON.Encoder.Helpers.dict_encode(list)\n    else\n      JSON.Encoder.Helpers.enum_encode(list)\n    end\n  end\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof([]), do: :array\n\n  def typeof(list) do\n    if Keyword.keyword?(list) do\n      :object\n    else\n      :array\n    end\n  end\nend\n\ndefimpl JSON.Encoder, for: [Integer, Float] do\n  @doc \"\"\"\n  Converts Elixir Integer and Floats into JSON Numbers\n  \"\"\"\n  # Elixir converts octal, etc into decimal when putting in strings\n  def encode(number), do: {:ok, \"#{number}\"}\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof(_), do: :number\nend\n\ndefimpl JSON.Encoder, for: Atom do\n  @doc \"\"\"\n  Converts Elixir Atoms into their JSON equivalents\n  \"\"\"\n  def encode(nil), do: {:ok, \"null\"}\n  def encode(false), do: {:ok, \"false\"}\n  def encode(true), do: {:ok, \"true\"}\n  def encode(atom) when is_atom(atom), do: atom |> Atom.to_string() |> JSON.Encoder.encode()\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof(boolean) when is_boolean(boolean), do: :boolean\n  def typeof(nil), do: :null\n  def typeof(atom) when is_atom(atom), do: :string\nend\n\ndefimpl JSON.Encoder, for: BitString do\n  # 32 = ascii space, cleaner than using \"? \", I think\n  @acii_space 32\n\n  @doc \"\"\"\n  Converts Elixir String into JSON String\n  \"\"\"\n  def encode(bitstring), do: {:ok, <<?\">> <> encode_binary_recursive(bitstring, []) <> <<?\">>}\n\n  defp encode_binary_recursive(<<head::utf8, tail::binary>>, acc) do\n    encode_binary_recursive(tail, encode_binary_character(head, acc))\n  end\n\n  # stop cond\n  defp encode_binary_recursive(<<>>, acc), do: acc |> Enum.reverse() |> to_string\n\n  defp encode_binary_character(?\", acc), do: [?\", ?\\\\ | acc]\n  defp encode_binary_character(?\\b, acc), do: [?b, ?\\\\ | acc]\n  defp encode_binary_character(?\\f, acc), do: [?f, ?\\\\ | acc]\n  defp encode_binary_character(?\\n, acc), do: [?n, ?\\\\ | acc]\n  defp encode_binary_character(?\\r, acc), do: [?r, ?\\\\ | acc]\n  defp encode_binary_character(?\\t, acc), do: [?t, ?\\\\ | acc]\n  defp encode_binary_character(?\\\\, acc), do: [?\\\\, ?\\\\ | acc]\n\n  defp encode_binary_character(char, acc) when is_number(char) and char < @acii_space do\n    encode_hexadecimal_unicode_control_character(char, [?u, ?\\\\ | acc])\n  end\n\n  # anything else besides these control characters, just let it through\n  defp encode_binary_character(char, acc) when is_number(char), do: [char | acc]\n\n  defp encode_hexadecimal_unicode_control_character(char, acc) when is_number(char) do\n    [\n      char\n      |> Integer.to_charlist(16)\n      |> zeropad_hexadecimal_unicode_control_character\n      |> Enum.reverse()\n      | acc\n    ]\n  end\n\n  defp zeropad_hexadecimal_unicode_control_character([a, b, c]), do: [?0, a, b, c]\n  defp zeropad_hexadecimal_unicode_control_character([a, b]), do: [?0, ?0, a, b]\n  defp zeropad_hexadecimal_unicode_control_character([a]), do: [?0, ?0, ?0, a]\n  defp zeropad_hexadecimal_unicode_control_character(iolist) when is_list(iolist), do: iolist\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof(_), do: :string\nend\n\ndefimpl JSON.Encoder, for: Record do\n  @doc \"\"\"\n  Encodes elixir records into json objects\n  \"\"\"\n  def encode(record), do: record.to_keywords |> JSON.Encoder.Helpers.dict_encode()\n\n  @doc \"\"\"\n  Encodes a record into a JSON object\n  \"\"\"\n  def typeof(_), do: :object\nend\n\ndefimpl JSON.Encoder, for: Map do\n  @doc \"\"\"\n  Encodes maps into object\n  \"\"\"\n  def encode(map), do: map |> JSON.Encoder.Helpers.dict_encode()\n\n  @doc \"\"\"\n  Returns an atom that represents the JSON type for the term\n  \"\"\"\n  def typeof(_), do: :object\nend\n\ndefimpl JSON.Encoder, for: Any do\n  @moduledoc \"\"\"\n  Falllback module for encoding any other values\n  \"\"\"\n\n  @doc \"\"\"\n  Encodes a map into a JSON object\n  \"\"\"\n  def encode(%{} = struct) do\n    struct\n    |> Map.to_list()\n    |> JSON.Encoder.Helpers.dict_encode()\n  end\n\n  @doc \"\"\"\n  Fallback method\n  \"\"\"\n  def encode(x) do\n    x\n    |> Kernel.inspect()\n    |> JSON.Encoder.encode()\n  end\n\n  @doc \"\"\"\n  Fallback method\n  \"\"\"\n  def typeof(struct) when is_map(struct), do: :object\n  def typeof(_), do: :string\nend","coverage":[null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,17,12,null,5,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,43,null,null,null,null,null,null,null,null,null,null,null,null,null,null,32,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,420,null,null,null,51,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null]},{"name":"lib/json/encoder/errors.ex","source":"defmodule JSON.Decoder.Error do\n  @moduledoc \"\"\"\n  Thrown when an unknown decoder error happens\n  \"\"\"\n  defexception message: \"Invalid JSON - unknown error\"\nend\n\ndefmodule JSON.Decoder.UnexpectedEndOfBufferError do\n  @moduledoc \"\"\"\n  Thrown when the json payload is incomplete\n  \"\"\"\n  defexception message: \"Invalid JSON - unexpected end of buffer\"\nend\n\ndefmodule JSON.Decoder.UnexpectedTokenError do\n  @moduledoc \"\"\"\n  Thrown when the json payload is invalid\n  \"\"\"\n  defexception token: nil\n\n  @doc \"\"\"\n    Invalid JSON - Unexpected token\n  \"\"\"\n  def message(exception), do: \"Invalid JSON - unexpected token >>#{exception.token}<<\"\nend\n\ndefmodule JSON.Encoder.Error do\n  @moduledoc \"\"\"\n  Thrown when an encoder error happens\n  \"\"\"\n  defexception error_info: nil\n\n  @doc \"\"\"\n    Invalid Term\n  \"\"\"\n  def message(exception) do\n    error_message = \"An error occurred while encoding the JSON object\"\n\n    if nil != exception.error_info do\n      error_message <> \" >>#{exception.error_info}<<\"\n    else\n      error_message\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null,null]},{"name":"lib/json/encoder/helpers.ex","source":"defmodule JSON.Encoder.Helpers do\n  @moduledoc \"\"\"\n  Helper functions for JSON.Encoder\n  \"\"\"\n\n  alias JSON.Encoder, as: Encoder\n\n  @doc \"\"\"\n  Given an enumerable encode the enumerable as an array.\n  \"\"\"\n  def enum_encode(coll) do\n    {:ok, \"[\" <> Enum.map_join(coll, \",\", &encode_item(&1)) <> \"]\"}\n  end\n\n  @doc \"\"\"\n  Given an enumerable that yields tuples of `{key, value}` encode the enumerable\n  as an object.\n  \"\"\"\n  def dict_encode(coll) do\n    {:ok,\n      \"{\" <>\n      Enum.map_join(coll, \",\", fn {key, object} ->\n        encode_item(key) <> \":\" <> encode_item(object)\n      end) <> \"}\"}\n  end\n\n  defp encode_item(item) do\n    case Encoder.encode(item) do\n      {:ok, encoded_item} -> encoded_item\n      # propagate error, will trigger error in map_join\n      err -> err\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,null,null,null,null,108,108,null,0,null,null,null]},{"name":"lib/json/parser.ex","source":"defmodule JSON.Parser do\n  @moduledoc \"\"\"\n  Implements a JSON Parser for Bitstring values\n  \"\"\"\n\n  alias JSON.Parser, as: Parser\n  alias Parser.Array, as: ArrayParser\n  alias Parser.Number, as: NumberParser\n  alias Parser.Object, as: ObjectParser\n  alias Parser.String, as: StringParser\n\n  require Logger\n\n  @doc \"\"\"\n  parses a valid JSON value, returns its elixir representation\n\n  ## Examples\n\n      iex> JSON.Parser.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.parse \"-hello\"\n      {:error, {:unexpected_token, \"-hello\"}}\n\n      iex> JSON.Parser.parse \"129245\"\n      {:ok, 129245, \"\"}\n\n      iex> JSON.Parser.parse \"7.something\"\n      {:ok, 7, \".something\"}\n\n      iex> JSON.Parser.parse \"-88.22suffix\"\n      {:ok, -88.22, \"suffix\"}\n\n      iex> JSON.Parser.parse \"-12e4and then some\"\n      {:ok, -1.2e+5, \"and then some\"}\n\n      iex> JSON.Parser.parse \"7842490016E-12-and more\"\n      {:ok, 7.842490016e-3, \"-and more\"}\n\n      iex> JSON.Parser.parse \"null\"\n      {:ok, nil, \"\"}\n\n      iex> JSON.Parser.parse \"false\"\n      {:ok, false, \"\"}\n\n      iex> JSON.Parser.parse \"true\"\n      {:ok, true, \"\"}\n\n      iex> JSON.Parser.parse \"\\\\\\\"7.something\\\\\\\"\"\n      {:ok, \"7.something\", \"\"}\n\n      iex> JSON.Parser.parse \"\\\\\\\"-88.22suffix\\\\\\\" foo bar\"\n      {:ok, \"-88.22suffix\", \" foo bar\"}\n\n      iex> JSON.Parser.parse \"\\\\\\\"star -> \\\\\\\\u272d <- star\\\\\\\"\"\n      {:ok, \"star -> ✭ <- star\", \"\"}\n\n      iex> JSON.Parser.parse \"[]\"\n      {:ok, [], \"\"}\n\n      iex> JSON.Parser.parse \"[\\\\\\\"foo\\\\\\\", 1, 2, 1.5] lala\"\n      {:ok, [\"foo\", 1, 2, 1.5], \" lala\"}\n\n      iex> JSON.Parser.parse \"{\\\\\\\"result\\\\\\\": \\\\\\\"this will be a elixir result\\\\\\\"} lalal\"\n      {:ok, Enum.into([{\"result\", \"this will be a elixir result\"}], Map.new), \" lalal\"}\n  \"\"\"\n\n  def parse(<<?[, _::binary>> = bin) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) starting ArrayParser.parse(bin)...\")\n    ArrayParser.parse(bin)\n  end\n  def parse(<<?{, _::binary>> = bin) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) starting ObjectParser.parse(bin)...\")\n    ObjectParser.parse(bin)\n  end\n  def parse(<<?\", _::binary>> = bin) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) starting ArrayParser.parse(bin)...\")\n    StringParser.parse(bin)\n  end\n\n  def parse(<<?-, number::utf8, _::binary>> = bin) when number in ?0..?9 do\n    Logger.debug(\"#{__MODULE__}.parse(bin) starting negative NumberParser.parse(bin)...\")\n    NumberParser.parse(bin)\n  end\n  def parse(<<number::utf8, _::binary>> = bin) when number in ?0..?9 do\n    Logger.debug(\"#{__MODULE__}.parse(bin) starting NumberParser.parse(bin)...\")\n    NumberParser.parse(bin)\n  end\n  def parse(<<?n, ?u, ?l, ?l, rest::binary>>) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) parsed `null` token.\")\n    {:ok, nil, rest}\n  end\n  def parse(<<?t, ?r, ?u, ?e, rest::binary>>) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) parsed `true` token.\")\n    {:ok, true, rest}\n  end\n  def parse(<<?f, ?a, ?l, ?s, ?e, rest::binary>>) do\n    Logger.debug(\"#{__MODULE__}.parse(bin) parsed `false` token.\")\n    {:ok, false, rest}\n  end\n  def parse(<<>>) do\n    Logger.debug(\"#{__MODULE__}.parse(<<>>) unexpected end of buffer.\")\n    {:error, :unexpected_end_of_buffer}\n  end\n  def parse(json) do\n    Logger.debug(\"#{__MODULE__}.parse(json) unexpected token: #{inspect json}\")\n    {:error, {:unexpected_token, json}}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,18,18,null,null,31,31,null,null,48,48,null,null,null,8,8,null,null,45,45,null,null,5,5,null,null,7,7,null,null,5,5,null,null,3,null,null,null,4,null,null,null]},{"name":"lib/json/parser/array.ex","source":"defmodule JSON.Parser.Array do\n  @moduledoc \"\"\"\n  Implements a JSON Array Parser for Bitstring values\n  \"\"\"\n\n  alias JSON.Parser, as: Parser\n\n  require Logger\n\n  @doc \"\"\"\n  parses a valid JSON array value, returns its elixir list representation\n\n  ## Examples\n\n      iex> JSON.Parser.Array.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.Array.parse \"[1, 2 \"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.Array.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.Array.parse \"[] lala\"\n      {:ok, [], \" lala\"}\n\n      iex> JSON.Parser.Array.parse \"[]\"\n      {:ok, [], \"\"}\n\n      iex> JSON.Parser.Array.parse \"[\\\\\\\"foo\\\\\\\", 1, 2, 1.5] lala\"\n      {:ok, [\"foo\", 1, 2, 1.5], \" lala\"}\n  \"\"\"\n  def parse(<<?[, rest::binary>>) do\n    Logger.debug(\"#{__MODULE__}.parse(#{inspect rest}) trimming string and the calling parse_array_contents()\")\n    rest |> String.trim() |> parse_array_contents()\n  end\n\n  def parse(<<>>) do\n    Logger.debug(\"#{__MODULE__}.parse(<<>>) unexpected end of buffer.\")\n    {:error, :unexpected_end_of_buffer}\n  end\n  def parse(json) do\n    Logger.debug(\"#{__MODULE__}.parse(<<>>) unexpected token: #{inspect json}\")\n    {:error, {:unexpected_token, json}}\n  end\n\n  # begin parse array\n  defp parse_array_contents(json) when is_binary(json) do\n    Logger.debug(\"#{__MODULE__}.parse_array_contents(#{inspect json}) beginning to parse array contents...\")\n    parse_array_contents([], json)\n  end\n\n  # stop condition\n  defp parse_array_contents(acc, <<?], rest::binary>>) do\n    Logger.debug(\"#{__MODULE__}.parse_array_contents(#{inspect acc}, #{inspect rest}) finished parsing array contents.\")\n    {:ok, Enum.reverse(acc), rest}\n  end\n\n  # error condition\n  defp parse_array_contents(_, <<>>) do\n    Logger.debug(\"#{__MODULE__}.parse_array_contents(acc, <<>>) unexpected end of buffer.\")\n    {:error, :unexpected_end_of_buffer}\n  end\n\n  defp parse_array_contents(acc, json) do\n    json |> String.trim() |> Parser.parse() |> case do\n      {:error, error_info} ->\n        Logger.debug(\"#{__MODULE__}.parse_array_contents(#{inspect acc}, #{inspect json}) generated an error: #{inspect error_info}\")\n        {:error, error_info}\n      {:ok, value, after_value} ->\n        Logger.debug(\"#{__MODULE__}.parse_array_contents(acc, json) sucessfully parsed value `#{inspect value}`, with\n        after_value=#{inspect after_value}\")\n        after_value |> String.trim() |>\n          case do\n            <<?,, after_comma::binary>> ->\n              trimmed = String.trim(after_comma)\n              Logger.debug(\"#{__MODULE__}.parse_array_contents(acc, json) found a comma, continuing parsing of #{inspect trimmed}\")\n              parse_array_contents([value | acc], trimmed)\n            rest ->\n              Logger.debug(\"#{__MODULE__}.parse_array_contents(acc, json) continuing parsing of #{inspect rest}\")\n              parse_array_contents([value | acc], rest)\n         end\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,22,22,null,null,null,1,null,null,null,1,null,null,null,null,null,22,22,null,null,null,null,21,21,null,null,null,null,1,null,null,null,null,48,null,0,null,null,48,null,null,48,null,31,31,31,null,17,17,null,null,null,null]},{"name":"lib/json/parser/number.ex","source":"defmodule JSON.Parser.Number do\n  @moduledoc \"\"\"\n  Implements a JSON Numeber Parser for Bitstring values\n  \"\"\"\n\n  @doc \"\"\"\n  parses a valid JSON numerical value, returns its elixir numerical representation\n\n  ## Examples\n\n      iex> JSON.Parser.Number.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.Number.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.Number.parse \"-hello\"\n      {:error, {:unexpected_token, \"hello\"}}\n\n      iex> JSON.Parser.Number.parse \"129245\"\n      {:ok, 129245, \"\"}\n\n      iex> JSON.Parser.Number.parse \"7.something\"\n      {:ok, 7, \".something\"}\n\n      iex> JSON.Parser.Number.parse \"7.4566something\"\n      {:ok, 7.4566, \"something\"}\n\n      iex> JSON.Parser.Number.parse \"-88.22suffix\"\n      {:ok, -88.22, \"suffix\"}\n\n      iex> JSON.Parser.Number.parse \"-12e4and then some\"\n      {:ok, -1.2e+5, \"and then some\"}\n\n      iex> JSON.Parser.Number.parse \"7842490016E-12-and more\"\n      {:ok, 7.842490016e-3, \"-and more\"}\n  \"\"\"\n  def parse(<<?-, rest::binary>>) do\n    case parse(rest) do\n      {:ok, number, json} -> {:ok, -1 * number, json}\n      {:error, error_info} -> {:error, error_info}\n    end\n  end\n\n  def parse(binary) do\n    case binary do\n      <<number::utf8, _::binary>> when number in ?0..?9 ->\n        binary |> to_integer |> add_fractional |> apply_exponent\n\n      <<>> ->\n        {:error, :unexpected_end_of_buffer}\n\n      _ ->\n        {:error, {:unexpected_token, binary}}\n    end\n  end\n\n  # error condition\n  defp add_fractional({:error, error_info}), do: {:error, error_info}\n\n  # stop condition\n  defp add_fractional({:ok, acc, bin}) do\n    case bin do\n      <<?., after_dot::binary>> ->\n        case after_dot do\n          <<c::utf8, _::binary>> when c in ?0..?9 ->\n            {fractional, rest} = parse_fractional(after_dot, 0, 10.0)\n            {:ok, acc + fractional, rest}\n\n          _ ->\n            {:ok, acc, bin}\n        end\n\n      _ ->\n        {:ok, acc, bin}\n    end\n  end\n\n  defp parse_fractional(<<number::utf8, rest::binary>>, acc, power) when number in ?0..?9 do\n    parse_fractional(rest, acc + (number - ?0) / power, power * 10)\n  end\n\n  defp parse_fractional(json, acc, _) when is_binary(json), do: {acc, json}\n\n  # error condition\n  defp apply_exponent({:error, error_info}), do: {:error, error_info}\n\n  # stop condition\n  defp apply_exponent({:ok, acc, <<exponent::utf8, rest::binary>>}) when exponent in 'eE' do\n    case to_integer(rest) do\n      {:ok, power, rest} -> {:ok, acc * :math.pow(10, power), rest}\n      {:error, error_info} -> {:error, error_info}\n    end\n  end\n\n  defp apply_exponent({:ok, acc, json}), do: {:ok, acc, json}\n\n  defp to_integer(<<>>), do: {:error, :unexpected_end_of_buffer}\n\n  defp to_integer(binary) do\n    case Integer.parse(binary) do\n      {result, rest} when is_integer(result) and is_binary(rest) -> {:ok, result, rest}\n      :error -> {:error, {:unexpected_token, binary}}\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,11,10,null,null,null,null,null,62,null,59,null,null,null,null,null,null,null,null,null,null,null,null,null,null,59,null,19,null,15,15,null,null,4,null,null,null,40,null,null,null,null,34,null,null,null,null,null,null,null,null,null,12,12,null,null,null,null,47,null,null,null,null,71,71,null,null,null,null]},{"name":"lib/json/parser/object.ex","source":"defmodule JSON.Parser.Object do\n  @moduledoc \"\"\"\n  Implements a JSON Object Parser for Bitstring values\n  \"\"\"\n\n  alias JSON.Parser, as: Parser\n\n  @doc \"\"\"\n  parses a valid JSON object value, returns its elixir representation\n\n  ## Examples\n\n      iex> JSON.Parser.Object.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.Object.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.Object.parse \"[] \"\n      {:error, {:unexpected_token, \"[] \"}}\n\n      iex> JSON.Parser.Object.parse \"[]\"\n      {:error, {:unexpected_token, \"[]\"}}\n\n      iex> JSON.Parser.Object.parse \"[\\\\\\\"foo\\\\\\\", 1, 2, 1.5] lala\"\n      {:error, {:unexpected_token, \"[\\\\\\\"foo\\\\\\\", 1, 2, 1.5] lala\"}}\n\n      iex> JSON.Parser.Object.parse \"{\\\\\\\"result\\\\\\\": \\\\\\\"this will be a elixir result\\\\\\\"} lalal\"\n      {:ok, Enum.into([{\"result\", \"this will be a elixir result\"}], Map.new), \" lalal\"}\n  \"\"\"\n  def parse(<<?{, rest::binary>>) do\n    rest\n    |> String.trim()\n    |> parse_object_contents()\n  end\n\n  def parse(<<>>), do: {:error, :unexpected_end_of_buffer}\n  def parse(json), do: {:error, {:unexpected_token, json}}\n\n  # Object Parsing\n  defp parse_object_key(json) do\n    case Parser.String.parse(json) do\n      {:error, error_info} -> {:error, error_info}\n      {:ok, key, after_key} ->\n        case String.trim(after_key) do\n          <<?:, after_colon::binary>> ->\n            {:ok, key, String.trim(after_colon)}\n          <<>> ->\n            {:error, :unexpected_end_of_buffer}\n          _ ->\n            {:error, {:unexpected_token, String.trim(after_key)}}\n        end\n    end\n  end\n\n  defp parse_object_value(acc, key, after_key) do\n    case Parser.parse(after_key) do\n      {:error, error_info} ->\n        {:error, error_info}\n      {:ok, value, after_value} ->\n        acc = Map.put(acc, key, value)\n        after_value |> String.trim() |>\n          case do\n            <<?,, after_comma::binary>> ->\n              parse_object_contents(acc, String.trim(after_comma))\n            rest ->\n              parse_object_contents(acc, rest)\n          end\n    end\n  end\n\n  defp parse_object_contents(json), do: parse_object_contents(Map.new(), json)\n\n  defp parse_object_contents(acc, <<?\", _::binary>> = bin) do\n    case parse_object_key(bin) do\n      {:error, error_info} -> {:error, error_info}\n      {:ok, key, after_key} -> parse_object_value(acc, key, after_key)\n    end\n  end\n\n  defp parse_object_contents(acc, <<?}, rest::binary>>), do: {:ok, acc, rest}\n  defp parse_object_contents(_, <<>>), do: {:error, :unexpected_end_of_buffer}\n  defp parse_object_contents(_, json), do: {:error, {:unexpected_token, json}}\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,32,null,null,null,null,null,null,null,34,null,null,34,null,32,null,null,null,null,null,null,null,null,null,32,null,null,null,30,null,30,null,10,null,20,null,null,null,null,32,null,null,34,null,32,null,null,null,20,null,null,null]},{"name":"lib/json/parser/record/chunk.ex","source":"defmodule JSON.Parser.Record.Chunk do\n  @moduledoc false\n  defstruct chunk: \"\", chunk_id: 0\nend","coverage":[null,null,null,null]},{"name":"lib/json/parser/string.ex","source":"defmodule JSON.Parser.String do\n  @moduledoc \"\"\"\n  Implements a JSON String Parser for Bitstring values\n  \"\"\"\n\n  alias JSON.Parser.Unicode, as: UnicodeParser\n\n  use Bitwise\n\n  @doc \"\"\"\n  parses a valid JSON string, returns its elixir representation\n\n  ## Examples\n\n      iex> JSON.Parser.String.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.String.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.String.parse \"-hello\"\n      {:error, {:unexpected_token, \"-hello\"}}\n\n      iex> JSON.Parser.String.parse \"129245\"\n      {:error, {:unexpected_token, \"129245\"}}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"7.something\\\\\\\"\"\n      {:ok, \"7.something\", \"\"}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"-88.22suffix\\\\\\\" foo bar\"\n      {:ok, \"-88.22suffix\", \" foo bar\"}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"star -> \\\\\\\\u272d <- star\\\\\\\"\"\n      {:ok, \"star -> ✭ <- star\", \"\"}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"\\\\\\\\u00df ist wunderbar\\\\\\\"\"\n      {:ok, \"ß ist wunderbar\", \"\"}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"Rafaëlla\\\\\\\" foo bar\"\n      {:ok, \"Rafaëlla\", \" foo bar\"}\n\n      iex> JSON.Parser.String.parse \"\\\\\\\"Éloise woot\\\\\\\" Éloise\"\n      {:ok, \"Éloise woot\", \" Éloise\"}\n  \"\"\"\n  def parse(<<?\"::utf8, json::binary>>), do: parse_string_contents(json, [])\n  def parse(<<>>), do: {:error, :unexpected_end_of_buffer}\n  def parse(json), do: {:error, {:unexpected_token, json}}\n\n  # stop conditions\n  defp parse_string_contents(<<>>, _), do: {:error, :unexpected_end_of_buffer}\n\n  # found the closing \", lets reverse the acc and encode it as a string!\n  defp parse_string_contents(<<?\"::utf8, json::binary>>, acc) do\n    encoded = acc |> Enum.reverse() |> List.to_string()\n    {:ok, encoded, json}\n  end\n\n  # parsing\n  defp parse_string_contents(<<?\\\\, ?f, json::binary>>, acc),\n    do: parse_string_contents(json, [?\\f | acc])\n\n  defp parse_string_contents(<<?\\\\, ?n, json::binary>>, acc),\n    do: parse_string_contents(json, [?\\n | acc])\n\n  defp parse_string_contents(<<?\\\\, ?r, json::binary>>, acc),\n    do: parse_string_contents(json, [?\\r | acc])\n\n  defp parse_string_contents(<<?\\\\, ?t, json::binary>>, acc),\n    do: parse_string_contents(json, [?\\t | acc])\n\n  defp parse_string_contents(<<?\\\\, ?\", json::binary>>, acc),\n    do: parse_string_contents(json, [?\" | acc])\n\n  defp parse_string_contents(<<?\\\\, ?\\\\, json::binary>>, acc),\n    do: parse_string_contents(json, [?\\\\ | acc])\n\n  defp parse_string_contents(<<?\\\\, ?/, json::binary>>, acc),\n    do: parse_string_contents(json, [?/ | acc])\n\n  defp parse_string_contents(<<?\\\\, ?u, _::binary>> = bin, acc) do\n    case UnicodeParser.parse(bin) do\n      {:error, error_info} ->\n        {:error, error_info}\n\n      {:ok, decoded_unicode_codepoint, after_codepoint} ->\n        case decoded_unicode_codepoint do\n          <<_::utf8>> ->\n            parse_string_contents(after_codepoint, [decoded_unicode_codepoint | acc])\n\n          _ ->\n            {:error, {:unexpected_token, bin}}\n        end\n    end\n  end\n\n  defp parse_string_contents(<<char::utf8, json::binary>>, acc) do\n    parse_string_contents(json, [char | acc])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,88,null,null,null,null,null,null,null,null,84,84,null,null,null,null,1,null,null,1,null,null,1,null,null,1,null,null,4,null,null,1,null,null,1,null,null,27,null,null,null,null,25,null,25,null,null,null,null,null,null,null,null,727,null,null]},{"name":"lib/json/parser/unicode.ex","source":"defmodule JSON.Parser.Unicode do\n  @moduledoc \"\"\"\n  Implements a JSON Unicode Parser for Bitstring values\n  \"\"\"\n\n  use Bitwise\n\n  @doc \"\"\"\n  parses a valid chain of escaped unicode and returns the string representation,\n  plus the remainder of the string\n\n  ## Examples\n\n      iex> JSON.Parser.parse \"\"\n      {:error, :unexpected_end_of_buffer}\n\n      iex> JSON.Parser.parse \"face0ff\"\n      {:error, {:unexpected_token, \"face0ff\"}}\n\n      iex> JSON.Parser.parse \"-hello\"\n      {:error, {:unexpected_token, \"-hello\"}}\n\n  \"\"\"\n  def parse(<<?\\\\, ?u, json::binary>>), do: parse_escaped_unicode_codepoint(json, 0, 0)\n  def parse(<<>>), do: {:error, :unexpected_end_of_buffer}\n  def parse(json), do: {:error, {:unexpected_token, json}}\n\n  # Parsing sugorrogate pairs\n  # http://unicodebook.readthedocs.org/unicode_encodings.html\n  # Inspired by Poison's function\n  defp parse_escaped_unicode_codepoint(\n         <<?d, hex::utf8, f1, f2, ?\\\\, ?u, ?d, hex2::utf8, s1, s2, json::binary>>,\n         _,\n         0\n       )\n       when hex >= 56 do\n    first_part = (List.to_integer([?d, hex, f1, f2], 16) &&& 1023) <<< 10\n    second_part = List.to_integer([?d, hex2, s1, s2], 16) &&& 1023\n    complete = 0x10000 + first_part + second_part\n    {:ok, <<complete::utf8>>, json}\n  end\n\n  # parse_escaped_unicode_codepoint tries to parse\n  # a valid hexadecimal (composed of 4 characters) value that potentially\n  # represents a unicode codepoint\n  defp parse_escaped_unicode_codepoint(json, acc, chars_parsed) when 4 === chars_parsed do\n    {:ok, <<acc::utf8>>, json}\n  end\n\n  defp parse_escaped_unicode_codepoint(<<hex::utf8, json::binary>>, acc, chars_parsed)\n       when hex in ?0..?9 do\n    parse_escaped_unicode_codepoint(json, 16 * acc + hex - ?0, chars_parsed + 1)\n  end\n\n  defp parse_escaped_unicode_codepoint(<<hex::utf8, json::binary>>, acc, chars_parsed)\n       when hex in ?a..?f do\n    parse_escaped_unicode_codepoint(json, 16 * acc + 10 + hex - ?a, chars_parsed + 1)\n  end\n\n  defp parse_escaped_unicode_codepoint(<<hex::utf8, json::binary>>, acc, chars_parsed)\n       when hex in ?A..?F do\n    parse_escaped_unicode_codepoint(json, 16 * acc + 10 + hex - ?A, chars_parsed + 1)\n  end\n\n  defp parse_escaped_unicode_codepoint(<<>>, _, _), do: {:error, :unexpected_end_of_buffer}\n  defp parse_escaped_unicode_codepoint(json, _, _), do: {:error, {:unexpected_token, json}}\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,18,18,18,18,null,null,null,null,null,null,7,null,null,null,null,26,null,null,null,null,6,null,null,null,null,0,null,null,null,null,null]}]}